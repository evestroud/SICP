* previous section:
    * how to design systems in which data objects can be represented in more than one way
    * key idea: 
        * link the code that specifies the data operations to the representations by way of generic interface procedures
* this section:
    * how to use this idea to also define operations that are generic over different kinds of arguments
    * have seen several different packages of arithmetic operations on different kinds of numbers:
        * primitive: `+-*/
        * rationals: `add-rat sub-rad mul-rat div-rat
        * complex: `add-complex sub-complex mul-complex div-complex
    * will now use data-directed techniques to construct a package that incorporates all the arithmetic packages we have seen so far
* structure of the system to be built:
    * Figure 2.23
    * single procedure `add` that operates on any number supplied
        * `add` is part of a generic interface that allows the separate arithmetic packages to be accessed with one entry point
    * any individual arithmetic packages (e.g. complex number package) may itself be accessed through its own generic procedures that combine packages for different representations (2.4)
    * structure is additive: 
        * individual arithmetic packages can be designed separately and combined

### 2.5.1 Generic Arithmetic Operations
* task of designing generic arithmetic operations 
    * analogous to that of designing the generic complex number operations
    * would like (for example) to have a generic addition procedure `add
        * acts like `+` on integers
        * acts like `add-rat` on rationals
        * acts like `add-complex` on complex numbers
    * can implement `add` by following the same strategy as 2.4.3
        * attach a type tag to each type of number
        * use type dispatch to call the appropriate package inside the generic procedure
* begin by installing a package for handling primitive numbers
    * tagged with `scheme-number
    * arithmetic operations in this package are primitive arithmetic procedures `+-*/
    * inserted into operation/type table using the operation name and parameter signature
    * external constructor created by `get`ting the procedure from the table
* using this framework, can easily add rational numbers
* complex numbers
    * can install the rectangular and polar packages from 2.4.3 as a single package by tagging either format with `'complex`
        * then internally using the generic complex number procedures to operate on the internal data type
    * programs from outside the complex number package can construct complex numbers from either real and imaginary parts or magnitude and angle
        * constructors are first exported from the rectangular and polar packages, then re-exported by the complex package
    * two-level tag system
        * outer tag (`'complex`) is used to direct the number to the complex number package
        * inner tack (`'rectangular` or `'polar`) is then used to direct the number to the appropriate implementation
    * a large and complicated system may have many levels of abstraction each with systems of generic operations
        * as a data object descends from higher levels of abstraction, outer tags are stripped off and more concrete procedures are accessed until raw data can be operated directly on